# 課題1
calc_magicnumber()ではhelloworld.txtをバイナリで読み出す。floatのポインタにそのまま強引に渡し、引数に対応するインデックスの部分をfloatとして返すようにした。main()側ではそれを順次受け取りf[i]に格納していき、最後に配列をchar*にキャストして文字列として出力した。

# 課題2
array.hで行列の集合を定義。4要素×100(index)のlong配列aからA(n)を参照できる。memo[]はそのインデックスの配列が既に完成しているかどうか(一度通ったかどうか)を表す。make_default()において行列の集合を確保し、memoを初期化する。

advance_array()ではA(n)を完成させる。nについてmemoが立っている場合はそのままだが立っていない場合はn/2についてadvance_array()を起動させ、n/2の二乗からA(n)を生成する。

偶奇の場合分けは基本の(1,1,1,0)を掛けるかどうかだけなので最後に行った。

fibo()は行列の集合を確保したのちにadvanve_array()で行列の集合を操作し、目当ての部分を返す。なお、本来なら行列の集合はmain内で作って使いまわせるようにしておくべきだが、fibo()以下で行列いじりが完結してほしかったためこの構成としている。あまり深く回してもlong値の限界を超えてしまい、またn<=90と指定があるのでメモリを解放しなくとも特に問題ない。

# 課題3
テストに使ったバイナリはitem.c内に実装したsave_itemset()から作ったsavedataというファイルである。これはload_itemset()と共に講義資料中のsoft2-220106-filereadのバイナリ読み書きを参考にして同じように実装してある。

先に品物数分の価値がdoubleで来た後にまとめて重さが品物数分来るという表記の都合上、先に価値だけ、重さだけを取り出した配列を新たに作ってから処理している。

# 課題4
solv.cに問題を解くsolve()、トータルの巡回距離を計算するcount_sum_distance()、初期解を生成するmake_first_trial()、配列の中身をコピーするcopy_int_array()、配列の要素を入れ替えるswap()を実装。

初期解の生成では時刻をseedにsrand()を用いている。rand()%n により0~nまでの乱数を生成し、配列にまだ入っていない要素であれば追加し、全ての要素が埋まるまでこれを繰り返す。この操作を初期解の分だけ繰り返し、一気に全ての初期解を作ってしまう。


solve()の中では「全ての初期解について」「改善できなくなるまで」「n個から2個を選ぶ組み合わせを全て選ぶ」操作を繰り返している。

